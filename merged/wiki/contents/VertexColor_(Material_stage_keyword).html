<html>
 <body>
  <a name="Description">
  </a>
  <h2>
   Description
  </h2>
  <p>
   The
   <i>
    vertexColor
   </i>
   keyword instructs the engine to multiply the given stage by the vertex color of the mesh to which the material is applied.
  </p>
  <a name="Usage">
  </a>
  <h2>
   Usage
  </h2>
  <pre>vertexColor
</pre>
  <a name="Parameters">
  </a>
  <h2>
   Parameters
  </h2>
  <p>
   This keyword does not accept parameters.
  </p>
  <a name="Example">
  </a>
  <h2>
   Example
  </h2>
  <p>
   The following stage will take the vertex color of the mesh into account...
  </p>
  <pre>{
 map           textures/custom/image1
 vertexColor
}
</pre>
  <a name="Notes">
  </a>
  <h2>
   Notes
  </h2>
  <p>
   This keyword uses color math where...
  </p>
  <pre>[Image Map] x [Vertex Color] = [Result]
</pre>
  <p>
   So for each texel across the surface of a mesh, the color of the image map and vertex color are sampled and then a result is calculated.
  </p>
  <p>
   So using the above formula here are some examples...
  </p>
  <pre>1.0 x 1.0  = 1.0
1.0 x 0.75 = 0.75
1.0 x 0.5  = 0.5
0.5 x 1.0  = 0.5
0.5 x 0.75 = 0.375
0.5 x 0.5  = 0.25
</pre>
  <p>
   Generally speaking, as the vertex color shifts from white to black, the image map will darken. If the vertex color is white, result is the same as the image map. If the vertex color is black, the result is black.
  </p>
  <p>
   This keyword is commonly used in conjunction with inverseVertexColor to create a material that blends between two textures based on vertex color. A very basic example would be like so...
  </p>
  <pre>{
 blend         add
 map           textures/custom/image1
 vertexColor
}
{
 blend         add
 map           textures/custom/image2
 inverseVertexColor
}
</pre>
  <p>
   <br/>
  </p>
 </body>
</html>
