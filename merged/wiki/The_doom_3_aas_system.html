





































































































<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>


<script type="text/javascript" src="/static/js/analytics.js"></script>
<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>


		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="keywords" content="The Doom 3 AAS system,Extending the Area Awareness System,Mr elusive's thesis,The annotated API,IdAI ::PointReachableAreaNum,AAS settings" />
<link rel="shortcut icon" href="/web/20081120142441im_/http://www.modwiki.net/favicon.ico" />
<link title="Creative Commons" type="application/rdf+xml" href="/w/index.php?title=The_Doom_3_AAS_system&amp;action=creativecommons" rel="meta" />
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<title>The Doom 3 AAS system - modwiki</title>
		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/web/20081120142441cs_/http://www.modwiki.net/w/skins/monobook/main.css?9"; /*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="/web/20081120142441cs_/http://www.modwiki.net/w/skins/common/commonPrint.css" />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/w/skins/monobook/IE50Fixes.css";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/w/skins/monobook/IE55Fixes.css";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/w/skins/monobook/IE60Fixes.css";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/w/skins/monobook/IE70Fixes.css?1";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/w/skins/common/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		<script type="text/javascript">var skin = 'monobook';var stylepath = '/w/skins';</script>
		<script type="text/javascript" src="/web/20081120142441js_/http://www.modwiki.net/w/skins/common/wikibits.js?1"><!-- wikibits js --></script>
		<script type="text/javascript" src="/web/20081120142441js_/http://www.modwiki.net/w/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/web/20081120142441cs_/http://www.modwiki.net/w/index.php?title=MediaWiki:Common.css&action=raw&ctype=text/css&smaxage=18000";
@import "/web/20081120142441cs_/http://www.modwiki.net/w/index.php?title=MediaWiki:Monobook.css&action=raw&ctype=text/css&smaxage=18000";
@import "/web/20081120142441cs_/http://www.modwiki.net/w/index.php?title=-&action=raw&gen=css&maxage=18000";
/*]]>*/</style>
		<!-- Head Scripts -->
			</head>
<body  class="ns-0 ltr">


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script> if (window.archive_analytics) { window.archive_analytics.values['server_name']="wwwb-app10.us.archive.org";}; </script>

<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript" src="/static/jflot/jquery.min.js" ></script>
<script type="text/javascript">
var __wm = (function(){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.modwiki.net/wiki/The_doom_3_aas_system";

var firstYear = 1996;
var imgWidth = 475,imgHeight = 27;
var yearImgWidth = 25,monthImgWidth = 2;
var displayDay = "20";
var displayMonth = "Nov";
var displayYear = "2008";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function getElementX2(obj) {
  var $e=jQuery(obj);
  return (typeof $e=="undefined"||typeof $e.offset=="undefined")?
    getElementX(obj):Math.round($e.offset().left);
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX2(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})();
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>
<div id="wm-ipp" lang="en" style="display:none;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="/web/" title="Wayback Machine home page"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.modwiki.net/wiki/The_doom_3_aas_system" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20081120142441"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="/web/20081006140206/http://www.modwiki.net/wiki/The_Doom_3_AAS_system" title="6 Oct 2008">OCT</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 14:24:41 Nov 20, 2008">NOV</td>
		<td class="f" nowrap="nowrap">
		
		    Dec
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="/web/20081006140206/http://www.modwiki.net/wiki/The_Doom_3_AAS_system" title="14:02:06 Oct 6, 2008"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 14:24:41 Nov 20, 2008">20</td>
	       <td class="f" nowrap="nowrap">
               
                   <img src="/static/images/toolbar/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0"/>
               
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="/web/20071117091249/http://www.modwiki.net/wiki/The_doom_3_aas_system" title="17 Nov 2007"><strong>2007</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 14:24:41 Nov 20, 2008">2008</td>
	       <td class="f" nowrap="nowrap">
               
                   2009
               
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="/web/20081120142441*/http://www.modwiki.net/wiki/The_doom_3_aas_system" title="See a list of every capture for this URL">14 captures</a>
           <div class="r" title="Timespan for captures of this URL">20 Mar 07 - 20 Nov 08</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines"
		 onmouseover="__wm.st(1)" onmouseout="__wm.st(0)"
		 onmousemove="__wm.mv(event,this)"
		 width="475"
		 height="27"
		 border="0"
		 src="/web/jsp/graph.jsp?graphdata=475_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:-1:001000100112_2008:10:100212000110_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000_2013:-1:000000000000_2014:-1:000000000000">
       </div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>
<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->

	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 class="firstHeading">The Doom 3 AAS system</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From modwiki</h3>
			<div id="contentSub">(Redirected from <a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_doom_3_aas_system&amp;redirect=no" title="The doom 3 aas system">The doom 3 aas system</a>)</div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class='toclevel-1'><a href="#Doom_3_AAS"><span class="tocnumber">1</span> <span class="toctext">Doom 3 AAS</span></a>
<ul>
<li class='toclevel-2'><a href="#Disclaimer"><span class="tocnumber">1.1</span> <span class="toctext">Disclaimer</span></a></li>
<li class='toclevel-2'><a href="#Credits"><span class="tocnumber">1.2</span> <span class="toctext">Credits</span></a></li>
<li class='toclevel-2'><a href="#Overview"><span class="tocnumber">1.3</span> <span class="toctext">Overview</span></a></li>
<li class='toclevel-2'><a href="#Creating_Areas"><span class="tocnumber">1.4</span> <span class="toctext">Creating Areas</span></a>
<ul>
<li class='toclevel-3'><a href="#Contents_of_volumes"><span class="tocnumber">1.4.1</span> <span class="toctext">Contents of volumes</span></a></li>
<li class='toclevel-3'><a href="#Portalisation"><span class="tocnumber">1.4.2</span> <span class="toctext">Portalisation</span></a></li>
<li class='toclevel-3'><a href="#Melting_things_together"><span class="tocnumber">1.4.3</span> <span class="toctext">Melting things together</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#Environment_Sampling"><span class="tocnumber">1.5</span> <span class="toctext">Environment Sampling</span></a>
<ul>
<li class='toclevel-3'><a href="#Finding_the_area_a_player_is_in"><span class="tocnumber">1.5.1</span> <span class="toctext">Finding the area a player is in</span></a></li>
<li class='toclevel-3'><a href="#Recursive_subdivision_by_the_bsp_tree"><span class="tocnumber">1.5.2</span> <span class="toctext">Recursive subdivision by the bsp tree</span></a></li>
<li class='toclevel-3'><a href="#Finding_the_areas_a_trace_goes_through"><span class="tocnumber">1.5.3</span> <span class="toctext">Finding the areas a trace goes through</span></a></li>
<li class='toclevel-3'><a href="#Areas_a_bounding_box_is_in"><span class="tocnumber">1.5.4</span> <span class="toctext">Areas a bounding box is in</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#Reachability"><span class="tocnumber">1.6</span> <span class="toctext">Reachability</span></a></li>
<li class='toclevel-2'><a href="#Routing"><span class="tocnumber">1.7</span> <span class="toctext">Routing</span></a>
<ul>
<li class='toclevel-3'><a href="#Multi-level_algorithm_that_calculates_cache"><span class="tocnumber">1.7.1</span> <span class="toctext">Multi-level algorithm that calculates cache</span></a></li>
<li class='toclevel-3'><a href="#Routing_cache_and_Clusters"><span class="tocnumber">1.7.2</span> <span class="toctext">Routing cache and Clusters</span></a></li>
<li class='toclevel-3'><a href="#Calculating_routing_caches"><span class="tocnumber">1.7.3</span> <span class="toctext">Calculating routing caches</span></a></li>
<li class='toclevel-3'><a href="#Using_routing_caches"><span class="tocnumber">1.7.4</span> <span class="toctext">Using routing caches</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#Other_stuff_that_could_be_talked_about"><span class="tocnumber">1.8</span> <span class="toctext">Other stuff that could be talked about</span></a></li>
</ul>
</li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=1" title="Edit section: Doom 3 AAS">edit</a>]</div><a name="Doom_3_AAS"></a><h1> Doom 3 AAS </h1>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=2" title="Edit section: Disclaimer">edit</a>]</div><a name="Disclaimer"></a><h2> Disclaimer </h2>
<p>The original intent of me writing all this down was to learn about the AAS system. Doom 3 is my first game programming experience and there is a lot to learn. I have found that writing it down as I go forces me to think through it in a way I normally wouldn’t. I hope it can be of use to someone and apologize for the poor organization and rough writing that follows.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=3" title="Edit section: Credits">edit</a>]</div><a name="Credits"></a><h2> Credits </h2>
<p>This entire thing is the result of me trying to understand the Area Awareness System system designed by J.M.P. van Waveren. His <a href="/web/20081120142441/http://www.modwiki.net/wiki/Mr_elusive%27s_thesis" title="Mr elusive's thesis">thesis paper</a> was invaluable in this process. Basically, all I did below is combine chapter 6 of the thesis with the doom 3 code. Credit goes out to him and all of id software for the kick ass games and sdk’s. Thanks JP for all the help and advice with the AAS stuff.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=4" title="Edit section: Overview">edit</a>]</div><a name="Overview"></a><h2> Overview </h2>
<p><i>“The Area Awareness System (AAS) is the whole system used to provide the bot with all the information about the current state of the world. This includes information about navigation, routing and also other entities in the game. All the information is formatted and preprocessed for fast and easy access and usage by the bot. The heart of AAS is a special 3D representation of the game world. All information provided to the bot is in
some way related to or linked with this 3D representation‿
</p><p>AAS uses 3D bounded hulls, called areas, with a specific property: the navigational complexity for traveling from any reachable point in an area to any other reachable point in the same area is minimal. … this means a player can move between any such two points by just walking or swimming along a straight line.
</p><p>Of course only knowing this property of each area does not provide all the information required for routing and navigation. However, so called reachabilities between areas can be calculated. Such a reachability is created from one area to another if a player can easily travel from one area to the other. Calculating these reachabilities is not all that difficult because a lot of areas will touch each other. When two areas touch, it can easily be verified if a player can really travel from one area to the other. This does not cover all the possible reachabilities between areas, but as will be shown later on, calculating other reachabilities is sometimes more complex, but definitely possible.
</p><p>The system, as it is presented here, is primarily focused on navigation and routing. However a lot of other information can be retrieved from or linked to this 3D representation.
</i>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=5" title="Edit section: Creating Areas">edit</a>]</div><a name="Creating_Areas"></a><h2> Creating Areas </h2>
<p><i>
‿All primitives used for collision… can now be expanded. All the space outside these expanded solid brushes is the space, where players can move around i.e. where the origin of the player bounding box can be. At this point convex hulls can be defined within this space. Within these convex hulls the player will be able to move with minimal navigational complexity. These convex hulls will become the areas of AAS‿
.</i>
</p><p>We should look at how an area is represented in code. A file that one needs to understand well if one wants to dig into doom 3 AAS is AASFile.h. Pop it open and look for this:
</p>
<pre>&nbsp;
<span style="color: #339900;">// area with a boundary of faces</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> aasArea_s <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">int</span> numFaces;				<span style="color: #339900;">// number of faces used for the boundary of the area</span>
	<span style="color: #0000ff;">int</span>	firstFace;			<span style="color: #339900;">// first face in the face index used for the boundary of the area</span>
	idBounds bounds;			<span style="color: #339900;">// bounds of the area</span>
	idVec3	center;	 			<span style="color: #339900;">// center of the area an AI can move towards</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>	 flags;			<span style="color: #339900;">// several area flags</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>	 contents;		<span style="color: #339900;">// contents of the area</span>
	<span style="color: #0000ff;">short</span> cluster;				<span style="color: #339900;">// cluster the area belongs to, if negative it's a portal</span>
	<span style="color: #0000ff;">short</span> clusterAreaNum;			<span style="color: #339900;">// number of the area in the cluster</span>
	<span style="color: #0000ff;">int</span>	travelFlags;			<span style="color: #339900;">// travel flags for traveling through this area</span>
	idReachability *	reach;	 	<span style="color: #339900;">// reachabilities that start from this area</span>
	idReachability *	rev_reach; 	<span style="color: #339900;">// reachabilities that lead to this area</span>
<span style="color: #000000;">&#125;</span> aasArea_t;</pre>
<p>An area is a convex space defined by the faces that bound it. An area keeps track of how many faces it has bounding it and the index of its first face. The actual faces are shared between areas and are stored independent of the area itself. 
</p><p>Areas keep track of what cluster they belong to by storing the index of that cluster. We will get into clusters and what they are soon.  
</p><p>Areas can be tagged with travel flags to indicate which type of travel is necessary to cross the area. Must one fly, walk, swim, etc. Travel flags are used to indicate what type of travel an AI entity can use. The flags are also declared in AASFile.h.
</p>
<pre>&nbsp;
<span style="color: #339900;">// travel flags</span>
<span style="color: #339900;">#define TFL_INVALID			BIT(0)		// not valid					</span>
<span style="color: #339900;">#define TFL_WALK			BIT(1)		// walking						</span>
<span style="color: #339900;">#define TFL_CROUCH			BIT(2)		// crouching					</span>
<span style="color: #339900;">#define TFL_WALKOFFLEDGE		BIT(3)		// walking of a ledge			</span>
<span style="color: #339900;">#define TFL_BARRIERJUMP			BIT(4)		// jumping onto a barrier		</span>
<span style="color: #339900;">#define TFL_JUMP			BIT(5)		// jumping						</span>
<span style="color: #339900;">#define TFL_LADDER			BIT(6)		// climbing a ladder			</span>
<span style="color: #339900;">#define TFL_SWIM			BIT(7)		// swimming					</span>
<span style="color: #339900;">#define TFL_WATERJUMP			BIT(8)		// jump out of the water		</span>
<span style="color: #339900;">#define TFL_TELEPORT			BIT(9)		// teleportation				</span>
<span style="color: #339900;">#define TFL_ELEVATOR			BIT(10)		// travel by elevator			</span>
<span style="color: #339900;">#define TFL_FLY				BIT(11)		// fly							</span>
<span style="color: #339900;">#define TFL_SPECIAL			BIT(12)		// special						</span>
<span style="color: #339900;">#define TFL_WATER			BIT(21)		// travel through water		</span>
<span style="color: #339900;">#define TFL_AIR				BIT(22)		// travel through air			</span></pre>
<p>We will look at how these travel flags are compared by the routing system later.
</p><p>Areas store a pointer to the first “reachability‿ in a list that is all reachabilities that lead from the area they represent to other surrounding areas. Areas also store a list of the reachabilities that lead to the area from other areas. these are stored in reach and rev_reach. idReachability details are also coming up soon.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=6" title="Edit section: Contents of volumes">edit</a>]</div><a name="Contents_of_volumes"></a><h3> Contents of volumes </h3>
<p><i>“… the contents of certain volumes is also defined with brushes. For instance a water volume is defined with a special brush. The same goes for lava and slime. These brushes that define a contents can also be expanded and compiled into the BSP tree. The leaf nodes that only contain (parts of) these brushes, that define content, can be marked as volumes with that content.</i>
</p><p>Areas can be flagged as having contents or attributes. These flags can mean just about anything you want. The flags are used by the goal and routing algorithms. They are stored in the flags member and use bit masks to do their work. Here they are, also from idAASFile.h:
</p>
<pre>&nbsp;
<span style="color: #339900;">// area flags</span>
<span style="color: #339900;">#define AREA_FLOOR			BIT(0)		// AI can stand on the floor in this area</span>
<span style="color: #339900;">#define AREA_GAP			BIT(1)		// area has a gap								</span>
<span style="color: #339900;">#define AREA_LEDGE			BIT(2)		// if entered the AI bbox partly floats above a ledge</span>
<span style="color: #339900;">#define AREA_LADDER			BIT(3)		// area contains one or more ladder faces</span>
<span style="color: #339900;">#define AREA_LIQUID			BIT(4)		// area contains a liquid	</span>
<span style="color: #339900;">#define AREA_CROUCH			BIT(5)		// AI cannot walk but can only crouch in this area</span>
<span style="color: #339900;">#define AREA_REACHABLE_WALK		BIT(6)		// area is reachable by walking or swimming	</span>
<span style="color: #339900;">#define AREA_REACHABLE_FLY		BIT(7)		// area is reachable by flying					</span></pre>
<p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=7" title="Edit section: Portalisation">edit</a>]</div><a name="Portalisation"></a><h3> Portalisation </h3>
<p><i>‿In order to calculate reachabilities and routes between areas (as will be done later on), another representation is required for the convex hulls (areas). The BSP tree does store all the information needed, but the representation cannot easily be used to calculate relations between areas. A representation with areas that are bounded by faces would be much more suitable. These faces are polygons that either represent solid walls or lead to other areas. With such a representation adjacency of areas can easily be determined, and it is easier to find or calculate geometric properties. Such a representation can be created by portalising the BSP tree. This technique creates portals between all the leaf nodes defined by the BSP tree. These portals are the faces
that bound the areas‿</i>
</p><p>We have already seen how areas store indexes to these faces. The representation of the face itself is in also in AASFile.h.
</p>
<pre>&nbsp;
<span style="color: #339900;">// area boundary face</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> aasFace_s <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>		planeNum;	<span style="color: #339900;">// number of the plane this face is on</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>		flags;		<span style="color: #339900;">// face flags</span>
	<span style="color: #0000ff;">int</span>			numEdges;	<span style="color: #339900;">// number of edges in the boundary of the face</span>
	<span style="color: #0000ff;">int</span>			firstEdge;	<span style="color: #339900;">// first edge in the edge index</span>
	<span style="color: #0000ff;">short</span>			areas<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;	<span style="color: #339900;">// area at the front and back of this face</span>
<span style="color: #000000;">&#125;</span> aasFace_t;</pre>
<p>The definition of a face contains the data necessary to define the geometric properties of the face. It is an area on a plane bounded by edges. It also stores the index of the two areas it divides.
Each face also can be tagged with flags. The flags defined in AASFile.h are listed below.
</p>
<pre>&nbsp;
<span style="color: #339900;">// face flags</span>
<span style="color: #339900;">#define FACE_SOLID			BIT(0)		// solid at the other side					</span>
<span style="color: #339900;">#define FACE_LADDER			BIT(1)		// ladder surface							</span>
<span style="color: #339900;">#define FACE_FLOOR			BIT(2)		// standing on floor when on this face		</span>
<span style="color: #339900;">#define FACE_LIQUID			BIT(3)		// face seperating two areas with liquid	</span>
<span style="color: #339900;">#define FACE_LIQUIDSURFACE		BIT(4)		// face seperating liquid and air			</span></pre>
<p><br />
<i>‿After portalisation the basic representation needed for AAS is created. However this portalised BSP tree still needs some work and the whole representation can be optimized in several ways. The BSP tree structure is also not thrown away at this point, because it is a very useful access structure to the areas of AAS, as will be shown later on. Each area, with the face boundary representation, is linked into the BSP tree at the node that represents its convex sub-space.‿</i>
</p><p>I will refer you to the thesis paper if you are interested in how the bsp tree is structured and created from the world space. The bsp tree is a tree of nodes which store the index of the plane that separates the two child nodes and the indexes to those children. 
</p><p>Here is that node definition from AASFile.h:
</p>
<pre>&nbsp;
<span style="color: #339900;">// nodes of the bsp tree</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> aasNode_s <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>	 planeNum;	<span style="color: #339900;">// number of the plane that splits the subspace at this node</span>
	<span style="color: #0000ff;">int</span>		children<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#93;</span>;	<span style="color: #339900;">// child nodes, zero is solid, negative is -(area number)</span>
<span style="color: #000000;">&#125;</span> aasNode_t;</pre>
<p>Note that a negative index for one of the children represents the negation of an area number. Areas are leaf nodes on the tree that result when the space in the map is no longer divided by a plane. We will look at how the bsp tree is walked later in environment sampling to find these areas.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=8" title="Edit section: Melting things together">edit</a>]</div><a name="Melting_things_together"></a><h3> Melting things together </h3>
<p><i>
“The data used for AAS is the collection of all the areas with their face boundary representation and the BSP-tree as a fast and very useful access structure to the areas. All the boundary representations of the areas will share data. The areas will share faces, edges of faces and vertices. This will allow to more easily find shared faces, edges and vertices between adjacent areas.‿
</i>
</p><p>This shared data is actually stored in the idAASFile class, again, declaration in AASFile.h:
</p>
<pre>&nbsp;
class idAASFile <span style="color: #000000;">&#123;</span>
&nbsp;
<span style="color: #339900; font-style: italic;">/* public functional interface removed for clarity */</span>
<span style="color: #0000ff;">protected</span>:
	idStr				name;
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span>			crc;
&nbsp;
	idPlaneSet			planeList;
	idList&lt;aasVertex_t&gt;		vertices;
	idList&lt;aasEdge_t&gt;		edges;
	idList&lt;aasIndex_t&gt;		edgeIndex;
	idList&lt;aasFace_t&gt;		faces;
	idList&lt;aasIndex_t&gt;		faceIndex;
	idList&lt;aasArea_t&gt;		areas;
	idList&lt;aasNode_t&gt;		nodes;
	idList&lt;aasPortal_t&gt;		portals;
	idList&lt;aasIndex_t&gt;		portalIndex;
	idList&lt;aasCluster_t&gt;		clusters;
	idAASSettings			settings;
<span style="color: #000000;">&#125;</span>;</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=9" title="Edit section: Environment Sampling">edit</a>]</div><a name="Environment_Sampling"></a><h2> Environment Sampling </h2>
<p><i>
“There are various ways to extract information from the 3D representation used for AAS. Especially the BSP tree is a very useful structure, which allows to calculate and extract certain information about the environment very easily.‿
</i>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=10" title="Edit section: Finding the area a player is in">edit</a>]</div><a name="Finding_the_area_a_player_is_in"></a><h3> Finding the area a player is in </h3>
<p><i>
“First of all it will be useful to know which area a bot is in. Using the BSP tree there is a very fast and easy way to calculate the area a bot is in. One can start at the root node of the BSP tree and calculate the side of the plane, stored at that node, the origin of the bot’s bounding box is at. Depending on the side of the plane the origin is at, one continues with one of the child nodes that represents either the sub-space at the front, or the sub-space at the back of the plane. At this child node one again calculates which side of the plane, stored at the child node, the origin of the bounding box is at, and one continues with one of it’s children accordingly. This procedure is continued until one of the areas of AAS is found. That area is the area the bot is situated in.‿
</i>
</p><p>The functionality to get the area the player or any point is in is implemented in the engine. The method signatures are declared in AASFile.h in the idAASFile class:
</p>
<pre>&nbsp;
class idAASFile <span style="color: #000000;">&#123;</span>
&nbsp;
<span style="color: #339900; font-style: italic;">/* removed irrelevant code */</span>
&nbsp;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span>	PointAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span>	PointReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin, <span style="color: #0000ff;">const</span> idBounds &amp;searchBounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> excludeTravelFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span>	BoundsReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idBounds &amp;bounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> excludeTravelFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;
&nbsp;
<span style="color: #339900; font-style: italic;">/* removed irrelevant code */</span></pre>
<p>PointAreaNum will return the area in the AAS system that a given point is in.
</p><p>PointReachableAreaNum, well, brian from id said it best:
<i>
“It returns the closest reachable area to the specified point.  If the point is in a reachable area already, it just returns that point, otherwise (for example if the given point is outside the world or inside some geometry) it will scan the bounding box given searching for reachable areas.‿
</p><p>“If a point is really far outside an area (it looks like the threshold is more than 12 units in all directions), then it will return 0.‿
</i>
So the same idea as PointAreaNum, but considers whether the area is reachable in its calculations.
<b> TODO: BoundsReachableAreaNum isn’t used right now but describe it anyway</b>
It is useful to know that these same methods names appear elsewhere in the sdk.
</p><p>In AAS.h the idAAS class is defined:
</p>
<pre>&nbsp;
class idAAS <span style="color: #000000;">&#123;</span>
<span style="color: #339900; font-style: italic;">/* removed irrelevant code */</span>
&nbsp;
<span style="color: #339900;">// Returns the number of the area the origin is in.</span>
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span>	PointAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;
&nbsp;
<span style="color: #339900;">// Returns the number of the nearest reachable area for the given point.</span>
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span>	PointReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin, <span style="color: #0000ff;">const</span> idBounds &amp;bounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;
&nbsp;
<span style="color: #339900;">// Returns the number of the first reachable area in or touching the bounds.</span>
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span> 	BoundsReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idBounds &amp;bounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;
&nbsp;
<span style="color: #339900; font-style: italic;">/* removed irrelevant code */</span></pre>
<p>We will look a lot more at idAAS as we go too. The idAAS definition is an interface. The actual implementation is in the class idAASLocal defined in AAS_local.h and implemented in AAS.cpp
</p>
<pre>&nbsp;
class idAASLocal&nbsp;: <span style="color: #0000ff;">public</span> idAAS <span style="color: #000000;">&#123;</span>
<span style="color: #339900; font-style: italic;">/* removed irrelevant code */</span>
&nbsp;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span> PointAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span> PointReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin, <span style="color: #0000ff;">const</span> idBounds &amp;searchBounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">int</span> BoundsReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idBounds &amp;bounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>;
&nbsp;
<span style="color: #339900; font-style: italic;">/* removed irrelevant code */</span></pre> 
<p>The implementation is just a wrapper around the idAASFile implementation:
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::PointAreaNum
============
*/</span>
<span style="color: #0000ff;">int</span> idAASLocal::<span style="color: #00aabb;">PointAreaNum</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!<span style="color: #0000ff;">file</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;
	<span style="color: #000000;">&#125;</span>
	<span style="color: #0000ff;">return</span> file-&gt;PointAreaNum<span style="color: #000000;">&#40;</span> origin <span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre>
<p>PointReachableAreaNum is actually also declared in idAI in AI.h:
</p>
<pre>&nbsp;
<span style="color: #0000ff;">Int</span> PointReachableAreaNum<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;pos, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">float</span> boundsScale = <span style="color: #0000dd;">2</span>.0f <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>;</pre>
<p>If you follow the implementation all the way back down from there you will see:
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
=====================
idAI::PointReachableAreaNum
=====================
*/</span>
<span style="color: #0000ff;">int</span> idAI::<span style="color: #00aabb;">PointReachableAreaNum</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;pos, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">float</span> boundsScale <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">int</span> areaNum;
	idVec3 size;
	idBounds bounds;
&nbsp;
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!aas <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;
	<span style="color: #000000;">&#125;</span>
	<span style="color: #339900;">// set up the bounding box that is used for reachability</span>
	size = aas-&gt;GetSettings<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>-&gt;boundingBoxes<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span> * boundsScale;
	bounds<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span> = -size;
	size.<span style="color: #00aabb;">z</span> = <span style="color: #0000dd;">32</span>.0f;
	bounds<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span> = size;
&nbsp;
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> move.<span style="color: #00aabb;">moveType</span> == MOVETYPE_FLY <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		areaNum = aas-&gt;PointReachableAreaNum<span style="color: #000000;">&#40;</span> pos, bounds, AREA_REACHABLE_WALK | AREA_REACHABLE_FLY <span style="color: #000000;">&#41;</span>;
	<span style="color: #000000;">&#125;</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">&#123;</span>
		areaNum = aas-&gt;PointReachableAreaNum<span style="color: #000000;">&#40;</span> pos, bounds, AREA_REACHABLE_WALK <span style="color: #000000;">&#41;</span>;
	<span style="color: #000000;">&#125;</span>
&nbsp;
	<span style="color: #0000ff;">return</span> areaNum;
<span style="color: #000000;">&#125;</span></pre>
<p>At the idAI level the work of setting up the bounding boxes and travel flags is done. idAI uses its instance of pointer to idAAS to get the bounds. At some point maybe a page about <a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=AAS_settings&amp;action=edit" class="new" title="AAS settings">AAS settings</a> will happen. 
</p><p>After <a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=IdAI_::PointReachableAreaNum&amp;action=edit" class="new" title="IdAI ::PointReachableAreaNum">idAI ::PointReachableAreaNum</a> does its work it calls AASLocal’s version of the same method.
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::PointReachableAreaNum
============
*/</span>
<span style="color: #0000ff;">int</span> idAASLocal::<span style="color: #00aabb;">PointReachableAreaNum</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idVec3 &amp;origin, <span style="color: #0000ff;">const</span> idBounds &amp;searchBounds, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> areaFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!<span style="color: #0000ff;">file</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span>;
	<span style="color: #000000;">&#125;</span>
&nbsp;
	<span style="color: #0000ff;">return</span> file-&gt;PointReachableAreaNum<span style="color: #000000;">&#40;</span> origin, searchBounds, areaFlags, TFL_INVALID <span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span></pre>
<p>Which is just a wrapper around idAASFile’s version, passing in the TFL_INVALID flag for excluded travel flags.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=11" title="Edit section: Recursive subdivision by the bsp tree">edit</a>]</div><a name="Recursive_subdivision_by_the_bsp_tree"></a><h3> Recursive subdivision by the bsp tree </h3>
<p><b>TODO</b>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=12" title="Edit section: Finding the areas a trace goes through">edit</a>]</div><a name="Finding_the_areas_a_trace_goes_through"></a><h3> Finding the areas a trace goes through </h3>
<p><b>Code dump for tracing. TODO</b>
</p>
<pre>&nbsp;
<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">bool</span> Trace<span style="color: #000000;">&#40;</span> aasTrace_t &amp;trace, <span style="color: #0000ff;">const</span> idVec3 &amp;start, <span style="color: #0000ff;">const</span> idVec3 &amp;end <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> = <span style="color: #0000dd;">0</span>;</pre>
<pre>&nbsp;
<span style="color: #339900;">// trace through the world</span>
<span style="color: #0000ff;">typedef</span> <span style="color: #0000ff;">struct</span> aasTrace_s <span style="color: #000000;">&#123;</span>
					<span style="color: #339900;">// parameters</span>
	<span style="color: #0000ff;">int</span>				flags;			<span style="color: #339900;">// areas with these flags block the trace</span>
	<span style="color: #0000ff;">int</span>				travelFlags;		<span style="color: #339900;">// areas with these travel flags block the trace</span>
	<span style="color: #0000ff;">int</span>				maxAreas;		<span style="color: #339900;">// size of the 'areas' array</span>
	<span style="color: #0000ff;">int</span>				getOutOfSolid;		<span style="color: #339900;">// trace out of solid if the trace starts in solid</span>
					<span style="color: #339900;">// output</span>
	<span style="color: #0000ff;">float</span>				fraction;		<span style="color: #339900;">// fraction of trace completed</span>
	idVec3				endpos;			<span style="color: #339900;">// end position of trace</span>
	<span style="color: #0000ff;">int</span>				planeNum;		<span style="color: #339900;">// plane hit</span>
	<span style="color: #0000ff;">int</span>				lastAreaNum;		<span style="color: #339900;">// number of last area the trace went through</span>
	<span style="color: #0000ff;">int</span>				blockingAreaNum;	<span style="color: #339900;">// area that could not be entered</span>
	<span style="color: #0000ff;">int</span>				numAreas;		<span style="color: #339900;">// number of areas the trace went through</span>
	<span style="color: #0000ff;">int</span> *				areas;			<span style="color: #339900;">// array to store areas the trace went through</span>
	idVec3 *			points;			<span style="color: #339900;">// points where the trace entered each new area</span>
					aasTrace_s<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> areas = <span style="color: #0000ff;">NULL</span>; points = <span style="color: #0000ff;">NULL</span>; getOutOfSolid = <span style="color: #0000ff;">false</span>; flags = travelFlags = maxAreas = <span style="color: #0000dd;">0</span>; <span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span> aasTrace_t;</pre>
<p><i>
“idAASFile::Trace actually allows you to get an ordered list of all areas the a line goes through if
you set aasTrace_t::areas to an integer array and aasTrace_t::maxAreas to the maximum number of elements in this array. The array will be filled in with the numbers of the areas the line went through and aasTrace_t::numAreas will be set to the number of areas.‿
</i>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=13" title="Edit section: Areas a bounding box is in">edit</a>]</div><a name="Areas_a_bounding_box_is_in"></a><h3> Areas a bounding box is in </h3>
<p><i>
“In order to calculate if the bot’s bounding box can or will touch the bounding boxes of other entities in the world, it is often useful to know in which area(s) the bounding boxes of entities are. To calculate this the bounding box of the entity has to be expanded, just like the brushes are expanded for collision calculations. This expansion is necessary, because the not expanded bounding box can be outside all areas, when at the same time the bot might be able to touch the bounding box while standing in a certain area. After expansion it can be calculated in which area(s) the bounding box resides, by testing on which side of the BSP tree split planes the bounding box is situated. This works similar to how the area a bot is in, is found. However a bounding box is now used instead of a point‿
</i>
</p><p>Side Note:You can use BoundsReachableAreaNum to return the number of the first reachable area in or touching the bounds you pass to it. 
</p><p>However if you want a list of the areas as described above you will have to take a look at idAASLocal::GetBoundsAreas_r. Before we look at it lets look at how it is used. The only place that it is called in the sdk is from idAASLocal::AddObstacle. The only thing to note from AddObstacle for now is how the bounds passed to GetBoundsArea_r are expanded and how the root node, 1, is passed to the GetBoundsAreas_r. We will get into how obstacles are used later.
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::AddObstacle
============
*/</span>
aasHandle_t idAASLocal::<span style="color: #00aabb;">AddObstacle</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idBounds &amp;bounds <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	idRoutingObstacle *obstacle;
&nbsp;
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!<span style="color: #0000ff;">file</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">return</span> -<span style="color: #0000dd;">1</span>;
	<span style="color: #000000;">&#125;</span>
&nbsp;
	obstacle = <span style="color: #0000dd;">new</span> idRoutingObstacle;
	obstacle-&gt;bounds<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span> = bounds<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span> - file-&gt;GetSettings<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">boundingBoxes</span><span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>;
	obstacle-&gt;bounds<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span> = bounds<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span> - file-&gt;GetSettings<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">boundingBoxes</span><span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>;
	GetBoundsAreas_r<span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">1</span>, obstacle-&gt;bounds, obstacle-&gt;areas <span style="color: #000000;">&#41;</span>;
	SetObstacleState<span style="color: #000000;">&#40;</span> obstacle, <span style="color: #0000ff;">true</span> <span style="color: #000000;">&#41;</span>;
&nbsp;
	obstacleList.<span style="color: #00aabb;">Append</span><span style="color: #000000;">&#40;</span> obstacle <span style="color: #000000;">&#41;</span>;
	<span style="color: #0000ff;">return</span> obstacleList.<span style="color: #00aabb;">Num</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> - <span style="color: #0000dd;">1</span>;
<span style="color: #000000;">&#125;</span></pre>
<p>Now for the actual routine. 
<i>
“One starts at the root node of the BSP tree and calculates which side of the plane, stored at that node, the bounding box is at.‿
</i>
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::GetBoundsAreas_r
============
*/</span>
<span style="color: #0000ff;">void</span> idAASLocal::<span style="color: #00aabb;">GetBoundsAreas_r</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">int</span> nodeNum, <span style="color: #0000ff;">const</span> idBounds &amp;bounds, idList&lt;int&gt; &amp;areas <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">int</span> res;
	<span style="color: #0000ff;">const</span> aasNode_t *node;
&nbsp;
	<span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span> nodeNum&nbsp;!= <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;</pre>
<p><i>
“This procedure is continued until all the areas of AAS the bounding box is in are found.‿
</i>
</p>
<pre>&nbsp;
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> nodeNum &lt; <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			areas.<span style="color: #00aabb;">Append</span><span style="color: #000000;">&#40;</span> -nodeNum <span style="color: #000000;">&#41;</span>;
			<span style="color: #0000ff;">break</span>;
		<span style="color: #000000;">&#125;</span></pre>
<p>To understand the check above it helps to understand how the bsp tree we are navigating was built. It is quite a bit of reading, and I don’t have code to annotate for it, so I will again refer you to chapter 6 in <a href="/web/20081120142441/http://www.modwiki.net/wiki/Mr_elusive%27s_thesis" title="Mr elusive's thesis">Mr_elusive's_thesis</a>.  The routine checks if the nodeNum is negative. It does this because nodes that have negative indexes are leaf nodes. So, when we find a negative nodeNum, we know we have found a leaf node that our bounds is in. We append the area index to the list passed in to be populated and break out of the loop. 
</p><p>If the nodeNum isn’t negative, we have to keep searching…
</p><p>“Depending on the side of the plane the bounding box is at one continues with one of the child nodes, that represents either the sub-space at the front or the sub-space at the back of the plane.
&lt;/i&gt;
</p>
<pre>&nbsp;
		node = &amp;file-&gt;GetNode<span style="color: #000000;">&#40;</span> nodeNum <span style="color: #000000;">&#41;</span>;
		res = bounds.<span style="color: #00aabb;">PlaneSide</span><span style="color: #000000;">&#40;</span> file-&gt;GetPlane<span style="color: #000000;">&#40;</span> node-&gt;planeNum <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> res == PLANESIDE_BACK <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			nodeNum = node-&gt;children<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>;
		<span style="color: #000000;">&#125;</span>
		<span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> res == PLANESIDE_FRONT <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			nodeNum = node-&gt;children<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>;
		<span style="color: #000000;">&#125;</span></pre>
<p>We find out which side of the splitting plane the bounding box is on and set the nodeNum to the child that represents that side of the plane for the next iteration through the loop.
</p><p><i> 
“In case the plane stored at the node splits the bounding box one continues with both children. 
</i>
</p>
<pre>&nbsp;
		<span style="color: #0000ff;">else</span> <span style="color: #000000;">&#123;</span>
			GetBoundsAreas_r<span style="color: #000000;">&#40;</span> node-&gt;children<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#93;</span>, bounds, areas <span style="color: #000000;">&#41;</span>;
			nodeNum = node-&gt;children<span style="color: #000000;">&#91;</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#93;</span>;
		<span style="color: #000000;">&#125;</span>
	<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre>
<p>By calling GetBoundsAreas_r recursively we are able to divide the search down two branches of the tree.
</p><p><i>
“At each child node one again calculates which side of the plane, stored at the child node, the bounding box is at, and one continues with one or both of it’s children accordingly.‿
</i>
In other words back to the top of the while loop.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=14" title="Edit section: Reachability">edit</a>]</div><a name="Reachability"></a><h2> Reachability </h2>
<p><i>
“Just the area representations are not sufficient for the bot to travel through the whole map. The bot will need to know how to travel from one area to the other, if possible at all. Therefore so-called reachabilities between areas are calculated. Such a reachability always starts in a certain area and leads to one other area. All possible reachabilities can be classified using about 12 different types...‿
</p><p>- Swimming in a straight line
- Walking in a straight line
- Crouching in a straight line
- Jumping onto a barrier
- Walking of a ledge
- Jumping out of the water
- Jumping
- Teleporting
- Using an elevator
- Using a jump pad
- Using a bobbing platform
- Rocket jumping
</i>
</p><p>Currently in doom 3 however:
<i>
“The Doom3 AAS compiler finds the following reachabilities:
</p><p>TFL_WALK
TFL_BARRIERJUMP
TFL_WALKOFFLEDGE
TFL_SWIM
TFL_WATERJUMP
TFL_FLY
</p><p>although the swim and fly reachabilities are only calculated if in the AAS
settings "allowSwimReachabilities" and "allowFlyReachabilities" are set
respectively. There tend to be a lot of fly reachabilities so we don't waste
memory to store them if there are no flying creatures in a level.
</p><p>Since the Doom3 AAS format is very open and the environment sampling
functionality is exposed through idAASFile as well it shouldn't be too hard
for third parties to write a tool that adds more reachabilities to an AAS
file.‿
</i>
The task of extending the AAS as described is underway; you can read about it over <a href="/web/20081120142441/http://www.modwiki.net/wiki/Extending_the_Area_Awareness_System" title="Extending the Area Awareness System">here</a>.
</p><p>idReachability is the class used to represent reachabilities in code. Its definition can be found in AASFile.h.
</p>
<pre>&nbsp;
<span style="color: #339900;">// reachability to another area</span>
class idReachability <span style="color: #000000;">&#123;</span>
<span style="color: #0000ff;">public</span>:
	<span style="color: #0000ff;">int</span>					travelType;		<span style="color: #339900;">// type of travel required to get to the area</span>
	<span style="color: #0000ff;">short</span>					toAreaNum;		<span style="color: #339900;">// number of the reachable area</span>
	<span style="color: #0000ff;">short</span>					fromAreaNum;		<span style="color: #339900;">// number of area the reachability starts</span>
	idVec3					start;			<span style="color: #339900;">// start point of inter area movement</span>
	idVec3					end;			<span style="color: #339900;">// end point of inter area movement</span>
	<span style="color: #0000ff;">int</span>					edgeNum;		<span style="color: #339900;">// edge crossed by this reachability</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>				travelTime;		<span style="color: #339900;">// travel time of the inter area movement</span>
	byte					number;			<span style="color: #339900;">// reachability number within the fromAreaNum (must be &lt; 256)</span>
	byte					disableCount;		<span style="color: #339900;">// number of times this reachability has been disabled</span>
	idReachability *			next;			<span style="color: #339900;">// next reachability in list</span>
	idReachability *			rev_next;		<span style="color: #339900;">// next reachability in reversed list</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span> *			areaTravelTimes;	<span style="color: #339900;">// travel times within the fromAreaNum from reachabilities that lead towards this area</span>
<span style="color: #0000ff;">public</span>:
	<span style="color: #0000ff;">void</span>					CopyBase<span style="color: #000000;">&#40;</span> idReachability &amp;reach <span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>;</pre>
<p>The first data member is travelType, this will hold the travel flags we looked at earlier. In this case it represents the type of travel necessary to use the reachability to get to the next area. A reachability connects the area in the map indexed as fromAreaNum to the area in the map indexed as toAreaNum. start and end represent the actual location the reachability starts and ends as a position vector. To get from one area to another you typically cross an edge that is shared between the two areas, the index of that edge is stored in edgeNum. Reachabilities are weighted so the routing algorithm can find the least cost path. That weight is stored in travelTime. Each reachability gets an index that represents the reachability in the area. This index is used by the routing system as we will see later. Dynamic obstacles may be added to the AAS system during game play. These obstacles may effectively block reachabilities from being used, disableCount tracks this occurrence. 
</p><p>Remember the definition for area, a pointer to a reachability is used to store all reachabilities for a given direction.
</p>
<pre>&nbsp;
	idReachability *			reach;				<span style="color: #339900;">// reachabilities that start from this area</span>
	idReachability *			rev_reach;			<span style="color: #339900;">// reachabilities that lead to this area</span>
<span style="color: #000000;">&#125;</span> aasArea_t;</pre>
<p>idReachabilities are linked into areas in two lists. The reach pointer above points to the first reachability that  starts in the area defined and ends in another area.The idReachability pointer “next‿ points to the next reachability in this list. Each reachability that leads from the area to another area is added to this list when the idAASFile is loaded. The same is true for rev_reach and rev_next, only for reachabilities that lead to the area are stored instead.  The routing system uses the graph formed by the areas and reachabilities to search for least cost paths from one location to another. We will look at this in depth later. The areaTravelTimes member of idReachability is an array of travel times across an area from other reachabilities that lead towards the area the reachability ends in. These travel times are calculated when the AAS system is initialized for quick lookup later by the routing system.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=15" title="Edit section: Routing">edit</a>]</div><a name="Routing"></a><h2> Routing </h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=16" title="Edit section: Multi-level algorithm that calculates cache">edit</a>]</div><a name="Multi-level_algorithm_that_calculates_cache"></a><h3> Multi-level algorithm that calculates cache </h3>
<p><i>
“The routing algorithm always calculates and caches routing data for a specific goal area. The routing cache stores per goal area, the travel times of areas towards this goal, and the first reachability to be used from these areas towards this goal..‿
</i>
This routing data is stored within idAASLocal which is declared in AAS_local.h:
</p>
<pre>&nbsp;
class idAASLocal&nbsp;: <span style="color: #0000ff;">public</span> idAAS <span style="color: #000000;">&#123;</span>
&nbsp;
<span style="color: #339900; font-style: italic;">/* removed unrelated code */</span>
&nbsp;
<span style="color: #0000ff;">private</span>:	<span style="color: #339900;">// routing data</span>
	idRoutingCache ***		areaCacheIndex;		<span style="color: #339900;">// for each area in each cluster the travel times to all other areas in the cluster</span>
	<span style="color: #0000ff;">int</span>				areaCacheIndexSize;	<span style="color: #339900;">// number of area cache entries</span>
	idRoutingCache **		portalCacheIndex;	<span style="color: #339900;">// for each area in the world the travel times from each portal</span>
	<span style="color: #0000ff;">int</span>				portalCacheIndexSize;	<span style="color: #339900;">// number of portal cache entries</span>
	idRoutingUpdate *		areaUpdate;		<span style="color: #339900;">// memory used to update the area routing cache</span>
	idRoutingUpdate *		portalUpdate;		<span style="color: #339900;">// memory used to update the portal routing cache</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span> *		goalAreaTravelTimes;	<span style="color: #339900;">// travel times to goal areas</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span> *		areaTravelTimes;	<span style="color: #339900;">// travel times through the areas</span>
	<span style="color: #0000ff;">int</span>				numAreaTravelTimes;	<span style="color: #339900;">// number of area travel times</span>
	mutable idRoutingCache *	cacheListStart;		<span style="color: #339900;">// start of list with cache sorted from oldest to newest</span>
	mutable idRoutingCache *	cacheListEnd;		<span style="color: #339900;">// end of list with cache sorted from oldest to newest</span>
	mutable <span style="color: #0000ff;">int</span>			totalCacheMemory;	<span style="color: #339900;">// total cache memory used</span>
	idList&lt;idRoutingObstacle *&gt;	obstacleList;		<span style="color: #339900;">// list with obstacles </span></pre>
<p>If some of these declarations seem unclear don’t worry, we will look at when and how this data is set up soon.
</p><p>Much of the data above is stored in a class named idRoutingCache, it is declared in the same file.
</p>
<pre>&nbsp;
class idRoutingCache <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">friend</span> class idAASLocal;
&nbsp;
<span style="color: #0000ff;">public</span>:
					idRoutingCache<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">int</span> size <span style="color: #000000;">&#41;</span>;
					~idRoutingCache<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#41;</span>;
&nbsp;
	<span style="color: #0000ff;">int</span>				Size<span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span>;
&nbsp;
<span style="color: #0000ff;">private</span>:
	<span style="color: #0000ff;">int</span>				type;			<span style="color: #339900;">// portal or area cache</span>
	<span style="color: #0000ff;">int</span>				size;			<span style="color: #339900;">// size of cache</span>
	<span style="color: #0000ff;">int</span>				cluster;		<span style="color: #339900;">// cluster of the cache</span>
	<span style="color: #0000ff;">int</span>				areaNum;		<span style="color: #339900;">// area of the cache</span>
	<span style="color: #0000ff;">int</span>				travelFlags;		<span style="color: #339900;">// combinations of the travel flags</span>
	idRoutingCache *		next;			<span style="color: #339900;">// next in list</span>
	idRoutingCache *		prev;			<span style="color: #339900;">// previous in list</span>
	idRoutingCache *		time_next;		<span style="color: #339900;">// next in time based list</span>
	idRoutingCache *		time_prev;		<span style="color: #339900;">// previous in time based list</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span>			startTravelTime;	<span style="color: #339900;">// travel time to start with</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">char</span> *			reachabilities;		<span style="color: #339900;">// reachabilities used for routing</span>
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span> *		travelTimes;		<span style="color: #339900;">// travel time for every area</span>
<span style="color: #000000;">&#125;</span>;</pre>
<p>Notice how each instance will store the area number and travel flags it was created for and as mentioned in the quote above, will store the travel times and first reachability to be used from each area towards the goal area. We will take a look at how idRoutingCache objects are created and linked into the routing cache in detail in a bit.
</p><p>Before that, let’s see how the system is initialized when a map loads. In idGameLocal::LoadMap:
</p>
<pre>&nbsp;
<span style="color: #339900;">// load navigation system for all the different monster sizes</span>
	<span style="color: #0000ff;">for</span><span style="color: #000000;">&#40;</span> i = <span style="color: #0000dd;">0</span>; i &lt; aasNames.<span style="color: #00aabb;">Num</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; i++ <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		aasList<span style="color: #000000;">&#91;</span> i <span style="color: #000000;">&#93;</span>-&gt;Init<span style="color: #000000;">&#40;</span> idStr<span style="color: #000000;">&#40;</span> mapFileName <span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">SetFileExtension</span><span style="color: #000000;">&#40;</span> aasNames<span style="color: #000000;">&#91;</span> i <span style="color: #000000;">&#93;</span> <span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">c_str</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, mapFile-&gt;GetGeometryCRC<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
	<span style="color: #000000;">&#125;</span></pre>
<p>Each size AAS file that exists for the given map is initialized. The initialization code is idAASLocal::Init:
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::Init
============
*/</span>
<span style="color: #0000ff;">bool</span> idAASLocal::<span style="color: #00aabb;">Init</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">const</span> idStr &amp;mapName, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> mapFileCRC <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">file</span> &amp;&amp; mapName.<span style="color: #00aabb;">Icmp</span><span style="color: #000000;">&#40;</span> file-&gt;GetName<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> == <span style="color: #0000dd;">0</span> &amp;&amp; mapFileCRC == file-&gt;GetCRC<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		common-&gt;Printf<span style="color: #000000;">&#40;</span> <span style="color: #666666;">"Keeping %s<span style="color: #666666; font-weight: bold;">\n</span>"</span>, file-&gt;GetName<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
		RemoveAllObstacles<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
	<span style="color: #000000;">&#125;</span>
	<span style="color: #0000ff;">else</span> <span style="color: #000000;">&#123;</span>
		Shutdown<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
&nbsp;
		<span style="color: #0000ff;">file</span> = AASFileManager-&gt;LoadAAS<span style="color: #000000;">&#40;</span> mapName, mapFileCRC <span style="color: #000000;">&#41;</span>;
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!<span style="color: #0000ff;">file</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			common-&gt;DWarning<span style="color: #000000;">&#40;</span> <span style="color: #666666;">"Couldn't load AAS file: '%s'"</span>, mapName.<span style="color: #00aabb;">c_str</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;
			<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;
		<span style="color: #000000;">&#125;</span>
		SetupRouting<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
	<span style="color: #000000;">&#125;</span>
	<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;
<span style="color: #000000;">&#125;</span></pre>
<p>AASFileManager-&gt;LoadAAS loads the .aas file into an instance of idAASFile. We looked at idAASFile and its lists of data earlier. After the area and reachability information is loaded into memory from the file SetupRouting is called.
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::SetupRouting
============
*/</span>
<span style="color: #0000ff;">bool</span> idAASLocal::<span style="color: #00aabb;">SetupRouting</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	CalculateAreaTravelTimes<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
	SetupRoutingCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
	<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;
<span style="color: #000000;">&#125;</span></pre>
<p>CalculateAreaTravelTimes initializes the areaTravelTime array of each reachability in the map. It also calculates and sets the maxAreaTravelTime for any portal areas.  We will see these travel times used later.
SetupRoutingCache initializes memory for all the routing cache data members we looked at earlier. If anyone would like more detail on these just ask.
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=17" title="Edit section: Routing cache and Clusters">edit</a>]</div><a name="Routing_cache_and_Clusters"></a><h3> Routing cache and Clusters </h3>
<p><i>
“The multi-level routing algorithm calculates routing caches at two levels. It calculates cache for areas in a cluster and it calculates cache for cluster portals. In a map one or more clusters with areas are created. Such a cluster is a group of connected areas. Shared bounding faces and reachabilities connect the areas. The clusters are separated by cluster portals, which are areas themselves. The only way to travel from one cluster
to another is through one or more cluster portals. A cluster portal always separates no more and no less than two clusters. The cache for areas in a cluster will be called area cache, and the cache for cluster portals, portal cache. The area cache stores the travel times of all areas within a cluster, including the cluster portal areas that touch the cluster, towards goal areas that are in the same cluster. The portal cache stores the travel times
of all portal areas in a map, towards a goal area which can be anywhere on the map. Such a goal area can be any area from any cluster, including cluster portal areas.‿
</i>
</p><p>Yeah, so if you didn’t quite catch that, you probably want to read it again before moving into the code that does it. Maybe I will upload a picture too someday. 
</p><p>First we will look again at a couple of declarations from above, they should make a little more sense now. An area cache and a portal cache to store routing data at two different levels.
</p>
<pre>&nbsp;
idRoutingCache ***	areaCacheIndex;			
idRoutingCache **	portalCacheIndex;</pre>
<p>Lets look at portalCacheIndex first. It is a pointer to a dynamically allocated array of pointers to idRoutingCaches. The array is indexed by goal area number. You will see it used later like this:
</p>
<pre>&nbsp;
<span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> cache-&gt;type == CACHETYPE_PORTAL <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		portalCacheIndex<span style="color: #000000;">&#91;</span>cache-&gt;areaNum<span style="color: #000000;">&#93;</span> = cache-&gt;next;
	<span style="color: #000000;">&#125;</span></pre>
<p>The neat part is the idRoutingCache pointed to by each area index is that it is actually part of a doubly linked list of idRoutingCaches. An instance is added to this list for each for each distinct set of travel flags requested for the area by the routing algorithm. So you will see loops like this later.
</p>
<pre>&nbsp;
<span style="color: #339900;">// check if cache without undesired travel flags already exists</span>
	<span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span> cache = portalCacheIndex<span style="color: #000000;">&#91;</span>areaNum<span style="color: #000000;">&#93;</span>; cache; cache = cache-&gt;next <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> cache-&gt;travelFlags == travelFlags <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			<span style="color: #0000ff;">break</span>;
		<span style="color: #000000;">&#125;</span>
	<span style="color: #000000;">&#125;</span></pre>
<p>Ok, got that. One more time, a pointer to an array of pointers to doubly linked lists of idRoutingCaches, indexed per goal area, linked per travel flags. he he, you remember what it is for now?  me either, here:
</p><p><i>
“The portal cache stores the travel times of all portal areas in a map, towards a goal area which can be anywhere on the map. Such a goal area can be any area from any cluster, including cluster portal areas.‿
</i>
</p><p>Good, now lets look at areaCacheIndex. Again, for reference:
</p>
<pre>&nbsp;
idRoutingCache ***	areaCacheIndex;</pre>
<p>areaCacheIndex is a pointer to a dynamically allocated two dimensional array of pointers to idRoutingCaches. The first dimension of the array is indexed by cluster number. The second dimension is indexed by area number. Perhaps an example:
</p>
<pre>&nbsp;
<span style="color: #339900;">// pointer to the cache for the area in the cluster</span>
	clusterCache = areaCacheIndex<span style="color: #000000;">&#91;</span>clusterNum<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span>;</pre>
<p>Try to think of it this way. What you have is an array of caches that represent the routing data for each cluster in the map. Clusters contain areas, so a clusters routing data is itself an array of routing data for areas. 
</p><p>Or maybe this way?
</p><p>A pointer to an array (indexed by cluster number) of arrays (each indexed by area number) of pointers to idRoutingCaches which represent the routing data for that area in that cluster. And don’t forget, idRoutingCaches are themselves doubly linked lists with a link for each set of travel flags passed in by the routing algorithm.
</p><p>Well, if it isn’t clear now, maybe it will be after we see it being used, and remember:
</p><p><i>
“The area cache stores the travel times of all areas within a cluster, including the cluster portal areas that touch the cluster, towards goal areas that are in the same cluster.‿
</i>
</p><p>Moving on…
</p><p><i>
“In general not all routing cache will be calculated. Routing cache will only be calculated and stored for areas the bot has had, or still has as a goal.‿
</i>
</p><p>We now know that there are actually two levels to the cache, a level for areas and a level for clusters. There are also two corresponding methods to get at this data for each level. GetAreaRoutingCache and GetPortalRoutingCache. We will look at GetAreaRoutingCache in detail and skip GetPortalRoutingCache as it is almost identical.
</p><p>GetAreaRoutingCache is called, passing in the cluster, area, and travel flags you would like routing data for. GetAreaRoutingCache checks to see if the appropriate data is already cached. If not, it creates it, caches it, then returns it.
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::GetAreaRoutingCache
============
*/</span>
idRoutingCache *idAASLocal::<span style="color: #00aabb;">GetAreaRoutingCache</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">int</span> clusterNum, <span style="color: #0000ff;">int</span> areaNum, <span style="color: #0000ff;">int</span> travelFlags <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">int</span> clusterAreaNum;
	idRoutingCache *cache, *clusterCache;</pre>
<p>If the area passed in is a cluster portal area (one of those that separate clusters) than the area actually belongs to two different clusters (the two it separates). It will have two different indexes, one that identifies it in each cluster. Areas are stored in an instance of idList in an idAASFile. The index of the area into this list is different then the index of the area that identifies it in a cluster. The call below to ClusterAreaNum returns the area number that represents the area in the cluster we asked for.
</p>
<pre>&nbsp;
	<span style="color: #339900;">// number of the area in the cluster</span>
	clusterAreaNum = ClusterAreaNum<span style="color: #000000;">&#40;</span> clusterNum, areaNum <span style="color: #000000;">&#41;</span>;</pre>
<p>We can now get the idRoutingCache object for the area and iterate through the linked list to find one that has the appropriate travel flags.
</p>
<pre>&nbsp;
&nbsp;
	<span style="color: #339900;">// pointer to the cache for the area in the cluster</span>
	clusterCache = areaCacheIndex<span style="color: #000000;">&#91;</span>clusterNum<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span>;
	<span style="color: #339900;">// check if cache without undesired travel flags already exists</span>
	<span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span> cache = clusterCache; cache; cache = cache-&gt;next <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> cache-&gt;travelFlags == travelFlags <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			<span style="color: #0000ff;">break</span>;
		<span style="color: #000000;">&#125;</span>
	<span style="color: #000000;">&#125;</span></pre>
<p>If we didn’t find a cache object, either because there wasn’t one for the area at all, or there wasn’t one with the appropriate flags, GetAreaRoutingCache will create it and insert it as the first node in the linked list
</p>
<pre>&nbsp;
	<span style="color: #339900;">// if no cache found</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!cache <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		cache = <span style="color: #0000dd;">new</span> idRoutingCache<span style="color: #000000;">&#40;</span> file-&gt;GetCluster<span style="color: #000000;">&#40;</span> clusterNum <span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">numReachableAreas</span> <span style="color: #000000;">&#41;</span>;
		cache-&gt;type = CACHETYPE_AREA;
		cache-&gt;cluster = clusterNum;
		cache-&gt;areaNum = areaNum;
		cache-&gt;startTravelTime = <span style="color: #0000dd;">1</span>;
		cache-&gt;travelFlags = travelFlags;
		cache-&gt;prev = <span style="color: #0000ff;">NULL</span>;
		cache-&gt;next = clusterCache;
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> clusterCache <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			clusterCache-&gt;prev = cache;
		<span style="color: #000000;">&#125;</span>
		areaCacheIndex<span style="color: #000000;">&#91;</span>clusterNum<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span> = cache;
		UpdateAreaRoutingCache<span style="color: #000000;">&#40;</span> cache <span style="color: #000000;">&#41;</span>;
	<span style="color: #000000;">&#125;</span>
	LinkCache<span style="color: #000000;">&#40;</span> cache <span style="color: #000000;">&#41;</span>;
	<span style="color: #0000ff;">return</span> cache;
<span style="color: #000000;">&#125;</span></pre>
<p>There are two methods called above that also deserve some attention. UpdateAreaRoutingCache and LinkCache. We will skip UpdateAreaRoutingCache for a moment and talk about LinkCache first:
</p><p>Remember in the definition of idRoutingCache:
</p>
<pre>&nbsp;
idRoutingCache *	time_next;		<span style="color: #339900;">// next in time based list</span>
idRoutingCache *	time_prev;		<span style="color: #339900;">// previous in time based list</span></pre>
<p>Because there is a cap on routing cache memory we want to track of all instances of idRoutingCache in the order they were created. LinkCache manages this doubly linked list. This allows us to delete the oldest data in the cache to make room for new data, which we will see happen later.
</p><p><br />
UpdateAreaRoutingCache brings us to the next section, one of my favorites…
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=18" title="Edit section: Calculating routing caches">edit</a>]</div><a name="Calculating_routing_caches"></a><h3> Calculating routing caches </h3>
<p>There are also two methods for calculating routing caches, one for each level of cache. UpdateAreaRoutingCache and UpdatePortalRoutingCache. We will look at both here. 
</p><p>UpdateAreaRoutingCache is called only from GetAreaRoutingCache which we just saw passes it an instance of idRoutingCache initialized with the area number for the goal area and the travel flags that may be used in calculating the routes to the area. Given this goal area UpdateAreaRoutingCache calculates the travel times from every other reachable area in the cluster to the goal area and stores them in the idRoutingCache travelTimes array. It also stores the first reachability to be used in the route from each of the areas in the reachabilities array member.
</p><p>There is some initialization code before the really cool stuff happens, here are the declarations.
</p>
<pre>&nbsp;
<span style="color: #339900; font-style: italic;">/*
============
idAASLocal::UpdateAreaRoutingCache
============
*/</span>
<span style="color: #0000ff;">void</span> idAASLocal::<span style="color: #00aabb;">UpdateAreaRoutingCache</span><span style="color: #000000;">&#40;</span> idRoutingCache *areaCache <span style="color: #000000;">&#41;</span> <span style="color: #0000ff;">const</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #0000ff;">int</span> i, nextAreaNum, cluster, badTravelFlags, clusterAreaNum, numReachableAreas;
	<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">short</span> t, startAreaTravelTimes<span style="color: #000000;">&#91;</span>MAX_REACH_PER_AREA<span style="color: #000000;">&#93;</span>;
	idRoutingUpdate *updateListStart, *updateListEnd, *curUpdate, *nextUpdate;
	idReachability *reach;
	<span style="color: #0000ff;">const</span> aasArea_t *nextArea;</pre>
<p>First we get the number of reachable areas within the cluster. As explained earlier we need to ensure that we have the area number that represents the area inside of the cluster, so a call to ClusterAreaNum is made to fetch that. I am not clear why the clusterAreaNum would ever be larger than the number of reachable areas, something to look into&nbsp;;)
</p>
<pre>&nbsp;
&nbsp;
	<span style="color: #339900;">// number of reachable areas within this cluster</span>
	numReachableAreas = file-&gt;GetCluster<span style="color: #000000;">&#40;</span> areaCache-&gt;cluster <span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">numReachableAreas</span>;
&nbsp;
	<span style="color: #339900;">// number of the start area within the cluster</span>
	clusterAreaNum = ClusterAreaNum<span style="color: #000000;">&#40;</span> areaCache-&gt;cluster, areaCache-&gt;areaNum <span style="color: #000000;">&#41;</span>;
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> clusterAreaNum &gt;= numReachableAreas <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">return</span>;
	<span style="color: #000000;">&#125;</span></pre>
<p>Next the travelTime for the current (goal) area is initialized to the startTravelTime, which was initialized to one before being passed in. the travelTimes array will store the travel times to this area from every area in the cluster. So 1 seems reasonable for a travel time to get to the goal position in the goal area itself.
</p>
<pre>&nbsp;
	areaCache-&gt;travelTimes<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span> = areaCache-&gt;startTravelTime;
	badTravelFlags = ~areaCache-&gt;travelFlags;
	<span style="color: #0000dd;">memset</span><span style="color: #000000;">&#40;</span> startAreaTravelTimes, <span style="color: #0000dd;">0</span>, <span style="color: #0000dd;">sizeof</span><span style="color: #000000;">&#40;</span> startAreaTravelTimes <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span>;</pre>
<p>The algorithm will check to make sure that each reachability it visits is valid for the current request’s travel flags. This is more easily done by flipping the bits and checking if the reachability contains travel flags that are not valid. startAreaTravelTimes is an array of unsigned shorts initialized to 0’s.
</p><p>Next we initialize curUpdate which is a pointer to an idRoutingUpdate object. An idRoutingUpdate object will be appointed for each area in the cluster that is reachable via the reversed reachability links stored from the goal area. It is then used to store the travel time it takes to get from the area it is created for to the goal area specified. 
</p>
<pre>&nbsp;
	<span style="color: #339900;">// initialize first update</span>
	curUpdate = &amp;areaUpdate<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span>;
	curUpdate-&gt;areaNum = areaCache-&gt;areaNum;
	curUpdate-&gt;areaTravelTimes = startAreaTravelTimes;
	curUpdate-&gt;tmpTravelTime = areaCache-&gt;startTravelTime;
	curUpdate-&gt;next = <span style="color: #0000ff;">NULL</span>;
	curUpdate-&gt;prev = <span style="color: #0000ff;">NULL</span>;
	updateListStart = curUpdate;
	updateListEnd = curUpdate;</pre>
<p><br />
First curUpdate is set to the address of the block of memory that was pre-allocated for it in SetupRoutingCache. This first idRoutingUpdate is created to represent the goal area itself, so its areaNum is set to the area number of the area cache we are calculating. The areaTravelTimes member is used to store travel times within the area from one reachability to another. It is set to all 0’s above. The tmpTravelTime will represent the time it takes to get from the area the routing update represents to the goal area, it is set to 1 for the goal area itself. idRoutingUpdates implement a linked list, the loop below processes updates in this list to flood the cluster calculating routing times. The last four lines above initialize that list to contain the newly initialized curUpdate as its only member. 
<i>
“The breadth first algorithm starts at the goal area and uses the reversed reachability links to flood to other areas.‿
</i>
</p><p>updateListStart has been initialized to the idRoutingUpdate that represents the goal area. we start flooding the cluster from this area. To do this we set curUpdate to the first update in the linked list and remove it from the list for processing. Below is that list management code.
</p>
<pre>&nbsp;
<span style="color: #339900;">// while there are updates in the list</span>
	<span style="color: #0000ff;">while</span><span style="color: #000000;">&#40;</span> updateListStart <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
&nbsp;
		curUpdate = updateListStart;
		<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> curUpdate-&gt;next <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
			curUpdate-&gt;next-&gt;prev = <span style="color: #0000ff;">NULL</span>;
		<span style="color: #000000;">&#125;</span>
		<span style="color: #0000ff;">else</span> <span style="color: #000000;">&#123;</span>
			updateListEnd = <span style="color: #0000ff;">NULL</span>;
		<span style="color: #000000;">&#125;</span>
		updateListStart = curUpdate-&gt;next;
&nbsp;
		curUpdate-&gt;isInList = <span style="color: #0000ff;">false</span>;</pre>
<p>For each area that we visit we will flood to all other reachable areas by following the reversed reachability links stored with that area:
</p>
<pre>&nbsp;
<span style="color: #0000ff;">for</span> <span style="color: #000000;">&#40;</span> i = <span style="color: #0000dd;">0</span>, reach = file-&gt;GetArea<span style="color: #000000;">&#40;</span> curUpdate-&gt;areaNum <span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">rev_reach</span>; reach; reach = reach-&gt;rev_next, i++ <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span></pre>
<p>Before deciding that the area the reversed reachability leads to is valid for the route, we check to see if the reachability and area it leads to require travel types that the AI requesting the route isn’t capable of, if so we do not process it any further.
</p>
<pre>&nbsp;
<span style="color: #339900;">// if the reachability uses an undesired travel type</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> reach-&gt;travelType &amp; badTravelFlags <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">continue</span>;
	<span style="color: #000000;">&#125;</span>
&nbsp;
	<span style="color: #339900;">// next area the reversed reachability leads to</span>
	nextAreaNum = reach-&gt;fromAreaNum;
	nextArea = &amp;file-&gt;GetArea<span style="color: #000000;">&#40;</span> nextAreaNum <span style="color: #000000;">&#41;</span>;
&nbsp;
	<span style="color: #339900;">// if traveling through the next area requires an undesired travel flag</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> nextArea-&gt;travelFlags &amp; badTravelFlags <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">continue</span>;
	<span style="color: #000000;">&#125;</span></pre>
<p><i>
“The algorithm never floods to areas outside the cluster. The algorithm does flood into cluster portals that touch the cluster.‿
</i>
</p>
<pre>&nbsp;
<span style="color: #339900;">// get the cluster number of the area</span>
	cluster = nextArea-&gt;cluster;
	<span style="color: #339900;">// don't leave the cluster, however do flood into cluster portals</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> cluster &gt; <span style="color: #0000dd;">0</span> &amp;&amp; cluster&nbsp;!= areaCache-&gt;cluster <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">continue</span>;
	<span style="color: #000000;">&#125;</span></pre>
<p>Remember, a negative cluster index would mean that the area is a cluster portal, hence the check for &gt; 0.
</p><p>Next a couple more checks to make sure the area we are flooding to is valid:
</p>
<pre>&nbsp;
<span style="color: #339900;">// get the number of the area in the cluster</span>
	clusterAreaNum = ClusterAreaNum<span style="color: #000000;">&#40;</span> areaCache-&gt;cluster, nextAreaNum <span style="color: #000000;">&#41;</span>;
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> clusterAreaNum &gt;= numReachableAreas <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		<span style="color: #0000ff;">continue</span>;	<span style="color: #339900;">// should never happen</span>
	<span style="color: #000000;">&#125;</span>
	<span style="color: #0000dd;">assert</span><span style="color: #000000;">&#40;</span> clusterAreaNum &lt; areaCache-&gt;size <span style="color: #000000;">&#41;</span>;</pre>
<p>If the area has passed all the checks above we will calculate the time it takes to get from the area to the goal area. To do this we add the time it takes to travel to the goal area from the area we are already in (curUpdate-&gt;tmpTravelTime)  and the time it takes to get from where we entered the current area across the area to the start of the reachability we are flooding through and the travel time of the reachability to get to the next area. this time is stored it t:
</p>
<pre>&nbsp;
<span style="color: #339900;">// time already travelled plus the traveltime through the current area</span>
<span style="color: #339900;">// plus the travel time of the reachability towards the next area</span>
t = curUpdate-&gt;tmpTravelTime + curUpdate-&gt;areaTravelTimes<span style="color: #000000;">&#91;</span>i<span style="color: #000000;">&#93;</span> + reach-&gt;travelTime;</pre>
<p>It usually sounds better when JP says it&nbsp;;):
<i>
“The reachabilities store a travel time, which is the time it takes the bot to travel along the reachability. These travel times are used in the routing algorithm. The areas are assumed to be nodes of a graph, but of course the areas are not points in space. It also takes time to travel through an area. These travel times through areas are also used in the routing algorithm. For each area a small table is used with travel times from every end point of a reachability that leads towards this area, to every start point of a reachability that starts in this area and leads to another area.‿
</i>
</p><p>Now that we know the travel time from the next area to the goal area we can check if it the fastest or first route we have found to that area:
</p>
<pre>&nbsp;
<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!areaCache-&gt;travelTimes<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span> || t &lt; areaCache-&gt;travelTimes<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span> <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span></pre>
<p>If it is, we store that time, and the first reachability to use to get towards the goal area in the areaCache object that was passed into UpdateAreaRoutingCache to be processed:
</p>
<pre>&nbsp;
areaCache-&gt;travelTimes<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span> = t;
areaCache-&gt;reachabilities<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span> = reach-&gt;number;</pre>
<p>We also now need to add that area to the list of areas to be flooded through, so we initialize and idRoutingUpdate for that area. Notice how it is initialized to have the tmpTravelTime set to the time that was already calculated it would take to get to the goal area and how the areaTravelTimes are set to the areaTravelTimes that were pre-calculated for the reachability way back when in CalculateAreaTravelTimes when the system was initialized.
</p>
<pre>&nbsp;
nextUpdate = &amp;areaUpdate<span style="color: #000000;">&#91;</span>clusterAreaNum<span style="color: #000000;">&#93;</span>;
nextUpdate-&gt;areaNum = nextAreaNum;
nextUpdate-&gt;tmpTravelTime = t;
nextUpdate-&gt;areaTravelTimes = reach-&gt;areaTravelTimes;</pre>
<p>The next step that happens is actually really cool. Sometimes a path that is the shortest isn’t always the best path to take. Paths can be weighted so that we can take more than just distance into account. A check is made to see if the area we are flooding to is near a ledge. If it is, and the AI isn’t capable of flying, this could be dangerous, so we add a penalty to this route so that if another route is available and not near a ledge, even if it is a longer route it is the better one to take.
</p>
<pre>&nbsp;
<span style="color: #339900;">// if we are not allowed to fly</span>
<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> badTravelFlags &amp; TFL_FLY <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	<span style="color: #339900;">// avoid areas near ledges</span>
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> file-&gt;GetArea<span style="color: #000000;">&#40;</span> nextAreaNum <span style="color: #000000;">&#41;</span>.<span style="color: #00aabb;">flags</span> &amp; AREA_LEDGE <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		nextUpdate-&gt;tmpTravelTime += LEDGE_TRAVELTIME_PANALTY;
	<span style="color: #000000;">&#125;</span>
<span style="color: #000000;">&#125;</span></pre>
<p>We then add the nextUpdate to the list of idRoutingUpdates to process and head back up to the top of the loop.
</p>
<pre>&nbsp;
<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span>&nbsp;!nextUpdate-&gt;isInList <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	nextUpdate-&gt;next = <span style="color: #0000ff;">NULL</span>;
	nextUpdate-&gt;prev = updateListEnd;
	<span style="color: #0000ff;">if</span> <span style="color: #000000;">&#40;</span> updateListEnd <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
		updateListEnd-&gt;next = nextUpdate;
	<span style="color: #000000;">&#125;</span>
	<span style="color: #0000ff;">else</span> <span style="color: #000000;">&#123;</span>
		updateListStart = nextUpdate;
	<span style="color: #000000;">&#125;</span>
	updateListEnd = nextUpdate;
	nextUpdate-&gt;isInList = <span style="color: #0000ff;">true</span>;
<span style="color: #000000;">&#125;</span></pre>
<p>Looking at the low level code detail by detail it is easy to miss what UpdateAreaRoutingCache is actually doing. Its purpose is to calculate and store the travel times from every area in the cluster to the goal area. these travel times are stored in the idRoutingCache passed to the routine. Each of the calculated travel times from an area is accompanied by the first idReachability the AI would use to take that route. Once this information is calculated it is cached for quick lookup so that future requests for the goal area do not need to recalculate the route. It does this by flooding, breadth first, through the cluster until every area that can be reached has its travel time calculated and stored in the areaCache object.
</p><p>So, in its entirety, it should now be clear:
</p><p><i>
“The area cache is calculated with a simple breadth first routing algorithm [11]. The areas are assumed to be nodes of a graph and the reachabilities the reversed links between the nodes. The breadth first algorithm starts at the goal area and uses the reversed reachability links to flood to other areas. The algorithm never floods to areas outside the cluster. The algorithm does flood into cluster portals that touch the cluster. The reachabilities store a travel time, which is the time it takes the bot to travel along the reachability. These travel times are used in the routing algorithm. The areas are assumed to be nodes of a graph, but of course the areas are not points in space. It also takes time to travel through an area. These travel times through areas are also used in
the routing algorithm. For each area a small table is used with travel times from every end point of a reachability that leads towards this area, to every start point of a reachability that starts in this area and leads to another area.‿
</i>
</p><p>&lt;TODO: UpdatePortalRoutingCache &gt;
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=19" title="Edit section: Using routing caches">edit</a>]</div><a name="Using_routing_caches"></a><h3> Using routing caches </h3>
<p>At this point I have really stopped trying to add to this particular tutorial and prefer annotating methods one at a time. Much of the work that continued on from this point can be found over in <a href="/web/20081120142441/http://www.modwiki.net/wiki/The_annotated_API" title="The annotated API">the annotated API</a>
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit&amp;section=20" title="Edit section: Other stuff that could be talked about">edit</a>]</div><a name="Other_stuff_that_could_be_talked_about"></a><h2> Other stuff that could be talked about </h2>
<p>Obstacles
Pathing: SubSampleWalkPath
Debug, cool visualizations&nbsp;;)
</p><p>Goals: FindNearestGoal – good stuff there.
</p><p>Another paper perhaps:
</p><p>Navigation: WalkPathToGoal, secondary goals, blah blah blah…
</p><div class="printfooter">
Retrieved from "<a href="/web/20081120142441/http://www.modwiki.net/wiki/The_Doom_3_AAS_system">http://www.modwiki.net/wiki/The_Doom_3_AAS_system</a>"</div>
			<div id="catlinks"><p class='catlinks'><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=Special:Categories&amp;article=The_Doom_3_AAS_system" title="Special:Categories">Category</a>: <span dir='ltr'><a href="/web/20081120142441/http://www.modwiki.net/wiki/Category:AI" title="Category:AI">AI</a></span><br /><hr /><a href="/web/20081120142441/http://www.modwiki.net/wiki/Category:Modwiki" title="Category:Modwiki">Modwiki</a> &gt; <a href="/web/20081120142441/http://www.modwiki.net/wiki/Category:Coding" title="Category:Coding">Coding</a> &gt; <a href="/web/20081120142441/http://www.modwiki.net/wiki/Category:AI" title="Category:AI">AI</a></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<ul>
				 <li id="ca-nstab-main" class="selected"><a href="/web/20081120142441/http://www.modwiki.net/wiki/The_Doom_3_AAS_system">Article</a></li>
				 <li id="ca-talk" class="new"><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=Talk:The_Doom_3_AAS_system&amp;action=edit">Discussion</a></li>
				 <li id="ca-edit"><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=edit">Edit</a></li>
				 <li id="ca-history"><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;action=history">History</a></li>
		</ul>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=Special:Userlogin&amp;returnto=The_Doom_3_AAS_system">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/web/20081120142441im_/http://www.modwiki.net/wiki/upload/wiki.png);" href="/web/20081120142441/http://www.modwiki.net/wiki/Main_Page" title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-Main'>
		<h5>Main</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Main_Page">Main Page</a></li>
			</ul>
		</div>
	</div>
		<div class='portlet' id='p-id Tech 4'>
		<h5>id Tech 4</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Doom-3"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Doom_3">Doom 3</a></li>
				<li id="n-Quake-4"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Quake_4">Quake 4</a></li>
				<li id="n-Prey"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Prey">Prey</a></li>
				<li id="n-ETQW"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Enemy_Territory:_Quake_Wars">ETQW</a></li>
				<li id="n-Wolfenstein"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Wolfenstein">Wolfenstein</a></li>
			</ul>
		</div>
	</div>
		<div class='portlet' id='p-id Tech 5'>
		<h5>id Tech 5</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Rage"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Rage">Rage</a></li>
				<li id="n-Doom-4"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Doom_4">Doom 4</a></li>
			</ul>
		</div>
	</div>
		<div class='portlet' id='p-Quick Links'>
		<h5>Quick Links</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Console"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Console">Console</a></li>
				<li id="n-Script-Events"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Scripting">Script Events</a></li>
				<li id="n-Material-Keywords"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Material_%28decl%29">Material Keywords</a></li>
				<li id="n-Modification-List"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Modlist">Modification List</a></li>
				<li id="n-Tutorial-List"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Tutorial_list">Tutorial List</a></li>
			</ul>
		</div>
	</div>
		<div class='portlet' id='p-Wiki'>
		<h5>Wiki</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Open-tasks"><a href="/web/20081120142441/http://www.modwiki.net/wiki/modwiki:Open_tasks">Open tasks</a></li>
				<li id="n-recentchanges"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Special:Recentchanges">Recent changes</a></li>
				<li id="n-Style-guide"><a href="/web/20081120142441/http://www.modwiki.net/wiki/modwiki:Style_guide">Style guide</a></li>
				<li id="n-help"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Help:Contents">Help</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/web/20081120142441/http://www.modwiki.net/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Special:Whatlinkshere/The_Doom_3_AAS_system">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Special:Recentchangeslinked/The_Doom_3_AAS_system">Related changes</a></li>
<li id="t-upload"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Special:Upload">Upload file</a></li>
<li id="t-specialpages"><a href="/web/20081120142441/http://www.modwiki.net/wiki/Special:Specialpages">Special pages</a></li>
				<li id="t-print"><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;printable=yes">Printable version</a></li>				<li id="t-permalink"><a href="/web/20081120142441/http://www.modwiki.net/w/index.php?title=The_Doom_3_AAS_system&amp;oldid=5290">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="/web/20081120142441/http://www.mediawiki.org/"><img src="/web/20081120142441im_/http://www.modwiki.net/w/skins/common/images/poweredby_mediawiki_88x31.png" alt="MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="/web/20081120142441/http://www.gnu.org/copyleft/fdl.html"><img src="/web/20081120142441im_/http://www.modwiki.net/w/skins/common/images/gnu-fdl.png" alt='GNU Free Documentation License 1.2' /></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 18:49, 16 December 2005.</li>
				<li id="copyright">Content is available under <a href="/web/20081120142441/http://www.gnu.org/copyleft/fdl.html" class='external ' title="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.2</a>.</li>
				<li id="privacy"><a href="/web/20081120142441/http://www.modwiki.net/wiki/modwiki:Privacy_policy" title="modwiki:Privacy policy">Privacy policy</a></li>
				<li id="about"><a href="/web/20081120142441/http://www.modwiki.net/wiki/modwiki:About" title="modwiki:About">About modwiki</a></li>
				<li id="disclaimer"><a href="/web/20081120142441/http://www.modwiki.net/wiki/modwiki:General_disclaimer" title="modwiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
	<script type="text/javascript"> if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by h982484 in 1.21 secs. -->
</body></html>





<!--
     FILE ARCHIVED ON 14:24:41 Nov 20, 2008 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 2:18:00 Oct 27, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
